# Measurement & Transmission of Temperature Data with Raspberry Pi, Python, NodeJS, REST, and WebSocket

By Jack Hermanson and Dallin Casey, 2021

## Abstract

This project reads the ambient temperature and humidity of the room in which it is located using a Raspberry Pi. It sends that information to a server, along with a secret key, which then stores it in the database. A React front end (client) then connects to that server, recevies the data it has in the database, and renders it on the screen for the end user. As new data comes in, the end user's screen is updated in real time.

## Introduction

Our project consists of 3 core parts: the Raspberry Pi, the NodeJS server, and the React client / front end. 

The Raspberry Pi uses a sensor called DHT-22 to read temperature data when prompted by a Python program. That Python program then sends the data its gathered over the Internet to a web server using an HTTP `POST` request. 

When the server receives that HTTP request, it 1) stores that data in the database, and 2) notifies the client that it has received new data via a websocket event. 

When the client is notified that new data has been received by the server, it initiates an HTTP `GET` request that fetches the information stored in the database. This allows the user to continuously receive up-to-date information without having to refresh their browser or restart any programs.

![](./overall-diagram.png)

## Problem Characterization

It's a relatively trivial task to read temperature data into a Python program on a Raspberry Pi and print it to the console. Things become more difficult when you want to actually transmit that data to the Internet and save it in a database. The problem is made even more difficult when you consider that users should be able to see the information as it is coming in, without having to restart the application (or refresh the page). 

Our problem has two parts:

1. Send the temperature information from the Raspberry Pi to a server over the Internet.
2. Update the end user's device in real time so they constantly receive up-to-date information.

## Proposed Solution and Implementation Strategy

### Obtaining Temperature Measurements

To obtain measurements of the ambient temperature, we attached a DHT-22 sensor to our Raspberry Pi with a Breadboard and some wires. Next, we wrote a small [Python](https://www.python.org/) program that accepts data generated by the sensor and sends them off to an API endpoint via HTTP `POST` requests. 

### Accepting and Storing Measurements

We implemented a simple HTTP server using [NodeJS](https://nodejs.org/en/about/) and the [Express](https://expressjs.com/) framework, written entirely in the [TypeScript](https://www.typescriptlang.org/) programming language. We also used the [TypeORM](https://typeorm.io/#/) library to manage our [PostgreSQL](https://www.postgresql.org/) database in production and [SQLite](https://www.sqlite.org/index.html) database in development. We also used the [jack-hermanson-ts-utils](https://www.npmjs.com/package/jack-hermanson-ts-utils) library, written and published by one of our group members.

In order to prevent bots or people with bad intentions from flooding our server with garbage data, our server **requires** that each request come with a secret **token** in its header, verifying that it is coming from the Raspberry Pi and no one else. The token is a long string of random hexademical digits. The following is an example of the body of a request the server may receive:

```json
{
  "temperature": 78.5,
  "humidity": 0.12,
  "generated": "2021-11-12T18:44:58.273Z"
}
```

Once the request has been authenticated (using its token, not shown above), the server takes the data from the request and stores it in the database.

### Sending Data to the Client

"Client" is a synonym for the "front end" of a web application. Our app is a [Progressive Web App](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps), which can run on the user's phone, computer, or web browser. Our client uses a popular front end library called [React](https://reactjs.org/) to paint the graphical user interface onto the screen. We also used the [Bootstrap](https://getbootstrap.com/) and [Reactstrap](https://reactstrap.github.io/?path=/story/home-installation--page) libraries to make the interface more aesthetically pleasing. We also used the [jack-hermanson-component-lib](https://www.npmjs.com/package/jack-hermanson-component-lib/v/1.3.2) library for reusable UI components and the [jack-hermanson-css-lib](https://www.npmjs.com/package/jack-hermanson-css-lib) library for aesthetics, both written and published by one of our group members. This portion of the app, like the server, was written entirely in the TypeScript programming language.

When the client side of the app first starts, it attempts to make a [websocket](https://en.wikipedia.org/wiki/WebSocket) connection with the server using [socket.io](https://socket.io/), which allows it to establish **bidirectional** communication. Once the connection has been made (this takes a fraction of a second), the client application uses [axios](https://axios-http.com/docs/intro) to send HTTP `GET` requests to fetch information from the database. The server responds to the `GET` request with information in an array like this:

```json
[
  {
    "id": 2,
    "temperature": 72.1,
    "humidity": 0.14,
    "generated": "2021-11-09T02:22:51.845Z",
    "created": "2021-11-09T02:22:58.000Z"
  },
  {
    "id": 1,
    "temperature": 71.8,
    "humidity": 0.15,
    "generated": "2021-11-07T01:25:51.845Z",
    "created": "2021-11-07T01:25:55.000Z"
  }
]
```

That array is stored in the client's browser memory as a **state** variable using the [easy-peasy](https://easy-peasy.vercel.app/) state management library. That state variable is accessible across all components of the app. It is **written to** in the `<SocketConnection />` component, but **read from** in the `<Measurements />` component.

We use an **enumeration** to define the **events** that the server might admit (in our case, there is only one, since it is a very simple app). The `<SocketConnection />` component, via its websocket connection, listens for the `NEW_MEASUREMENT` event, and executes a lambda function when it receives that event.

```typescript
socket.on(SocketEvent.NEW_MEASUREMENT, () => {
    console.log("New measurement");
    loadMeasurements();
});
```

That lambda function logs to the console, then calls the `loadMeasurements()` function, which uses axios to fetch the measurements from the server, as shown below:

```typescript
loadMeasurements: thunk(async actions => {
    try {
        const response = await axios.get<MeasurementRecord[]>(
            "/api/measurements"
        );
        const measurements = response.data;
        actions.setMeasurements(measurements);
    } catch (error) {
        console.error(error);
    }
}),
```

This is how the client is constantly synchronized with the data in the server's database.

## Conclusions

In conclusion, this development project was a success. We accomplished everything we set out to do and eliminated a security concern that came up along the way.

**TODO: ADD MORE**

## Bibliography

Ardumotive_com. [Raspberry Pi Tutorial: How to Use the DHT-22](https://www.instructables.com/Raspberry-Pi-Tutorial-How-to-Use-the-DHT-22/). 7 Oct 2018.

Mozilla Developer Network. [Progressive Web Apps](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps). 13 Oct 2021.